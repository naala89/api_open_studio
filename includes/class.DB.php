<?php

include_once(Config::$dirIncludes . 'class.Utilities.php');
include_once(Config::$dirIncludes . 'class.Debug.php');

class DB
{
  private $_sql;
  private $_result;
  private $db;
  private $transaction = FALSE;
  private $transactionOk = TRUE;

  public $debug = 0;

  /**
   * Constructor.
   *
   * Debug level will be taken from Config::$debugDb if it exists,
   * or default to off (0), it can also be overridden in the constructor.
   *
   * For CLI use, pass in SID to begin new session to save DB handle.
   *
   * @param mixed $debug
   *  [optional] debug level
   * @param string $sid
   *  [optional] session ID
   *
   * @return void
   **/
  public function DB($debug = NULL, $sid = NULL)
  {
    $this->debug = isset($debug) ? $debug : (class_exists('Config') && isset(Config::$debugDb) ? Config::$debugDb : 0);
    if ($this->debug > 0) {
      echo "<style type='text/css'>div.debug {background-color: #FFE7E7; border: solid #FF0000 1px;}</style>\n";
    }

    if (session_status() == PHP_SESSION_NONE) {
      if (!empty($sid)) {
        session_id($sid);
      }
      session_start();
    }

    if (empty($this->db) && class_exists('Config')) {
      $this->db = $this->connect(Config::$dbhost, Config::$dbname, Config::$dbuser, Config::$dbpass, Config::$dbpersistent);
    }

    $this->_clear();
  }

  /**
   * Destructor.
   *
   * Ensure the db handle is closed.
   */
  public function __destruct()
  {
    $this->close();
  }

  /**
   * Connect to the DB.
   *
   * Connect to the database $dbname on $dbhost
   * with the user/password pair $dbuser and $dbpass.
   *
   * @param string $host
   *  database host identifier
   * @param string $name
   *  database name
   * @param string $user
   *  db user
   * @param string $pass
   *  db pass
   * @param bool $persistent
   *  create a persistent connection
   *
   * @return handle
   */
  public function connect($host, $name, $user, $pass, $persistent)
  {
    if ($persistent) {
      $host = "p:$host";
    }
    $dbh = new mysqli($host, $user, $pass, $name);
    if ($dbh->connect_errno) {
      Debug::message('ERROR: Connection to mysql failed', 1, $this->debug);
      Debug::variable($host, 'host', 2, $this->debug);
      Debug::variable($user, 'user', 2, $this->debug);
      die("Failed to connect to MySQL: " . $dbh->connect_error());
    }
    return $dbh;
  }

  /**
   * Close the existing connection to the DB.
   *
   * @return void
   */
  public function close()
  {
    if (!empty($this->db)) {
      $this->db->close();
    }
  }

  /**
   * Execute the query.
   *
   * Accepts a manually created SQL string, or one generated by this class.
   *
   * @param string $sql
   *  manual input of sql string
   *
   * @return mixed
   */
  public function execute($sql = NULL)
  {
    $sql = $this->getQuery($sql);
    return $this->_exe($sql);
  }


  /**
   * Get SQL for the prepared values or input SQL
   *
   * @param mixed $sql
   * @return string
   */
  public function getQuery($sql = NULL)
  {
    if (empty($sql)) {
      switch ($this->_sql->type) {
        case 'SELECT':
          $sql = "{$this->_sql->type} {$this->_sql->cols} {$this->_sql->tables} {$this->_sql->where} {$this->_sql->orderBy} {$this->_sql->limit}";
          break;
        case 'INSERT':
          $sql = "{$this->_sql->type} {$this->_sql->tables} {$this->_sql->set} {$this->_sql->onDuplicate} {$this->_sql->where} {$this->_sql->orderBy} {$this->_sql->limit}";
          break;
        case 'UPDATE':
          $sql = "{$this->_sql->type} {$this->_sql->tables} {$this->_sql->set} {$this->_sql->where} {$this->_sql->orderBy} {$this->_sql->limit}";
          break;
        case 'DELETE':
          $sql = "{$this->_sql->type} {$this->_sql->tables} {$this->_sql->where} {$this->_sql->orderBy} {$this->_sql->limit}";
          break;
      }
    }

    return $sql;
  }

  /**
   * Begin a mysqli transaction.
   */
  public function beginTransaction()
  {
    Debug::message('Beginning transaction...', 1, $this->debug);
    $this->transaction = TRUE;
    $this->db->autocommit(FALSE);
  }

  /**
   * End a mysqli transaction.
   */
  public function endTransaction()
  {
    Debug::message('Ending transaction!', 1, $this->debug);
    if (!$this->transactionOk) {
      Debug::variable('The DB transaction failed and was rolled back', 'ERROR', 1, $this->debug);
      $this->db->rollback();
    } else {
      $this->db->commit();
    }
    $this->transaction = FALSE;
    $this->db->autocommit(TRUE);
  }

  /**.
   * Free query results from the server
   *
   * @return void
   */
  public function freeResult()
  {
    $this->_result->close();
  }

  /**
   * Create a select statement, with the columns required.
   *
   * select('col1')
   * select('col1 AS val1')
   * select(array('col1', 'col2'))
   * select(array('col1 AS alias1', 'col2 AS alias2'))
   * select(array('col1' => 'alias1', 'col2' => 'alias2'))
   *
   * @param mixed $cols
   *  array of column names or string of a column name
   *
   * @return this
   */
  public function select($cols=NULL)
  {
    $this->_sql->type = 'SELECT';

    if (empty($cols)) {
      $this->_sql->cols = '*';
    } elseif (!is_array($cols)) {
      $this->_sql->cols = $cols;
    } else {
      if (Utilities::is_assoc($cols)) {
        $cols = $this->_assoc_pairs($cols, 'AS');
      }
      $this->_sql->cols = implode(', ', $cols);
    }

    return $this;
  }

  /**
   * Create join to other table.
   *
   * join('inner join t2 on (t1.c1 = t2.c1)')
   * join(array('t2', array('t1.c1', '=', 't2.c1')))
   * join(array('t2', array('t1.c1', '=', 't2.c1'), 'outer'))
   *
   * @param mixed $joins
   *  array or string of joins
   *
   * @return this
   */
  public function joins($joins)
  {
    if (!is_array($joins)) {
      $this->_sql->joins .= " $joins";
    } else {
      foreach ($joins as $join) {
        $table = $joins[0];
        //$on = $this->_subWhere($joins[1]);
        $type = isset($join[2]) ? strtoupper($join[2]) : 'INNER';

        $this->_sql->joins .= " $type JOIN $table ON ($join)";
      }
    }

    return $this;
  }

  /**
   * Create an update statement, with the tables required.
   *
   * update('table1')
   * update(array('table1' => 'alias1'))
   * update(array('table1', 'table2'))
   *
   * @param mixed $tables
   *  array or string of tables
   *
   * @return this
   */
  public function update($tables)
  {
    $this->_sql->type = 'UPDATE';

    if (!is_array($tables)) {
      $this->_sql->tables = $tables;
    } else {
      if (Utilities::is_assoc($tables)) {
        $tables = $this->_assoc_pairs($tables, 'AS');
      }
      $this->_sql->tables = implode(', ', $tables);
    }

    return $this;
  }

  /**
   * Create an insert statement, with the tables required.
   *
   * insert('table1')
   *
   * @param str $table
   *  string of the table name
   *
   * @return this
   */
  public function insert($table)
  {
    $this->_sql->type = 'INSERT';
    $this->_sql->tables = "INTO $table";

    return $this;
  }

  /**
   * Create an delete statement, with the tables required.
   *
   * delete('table1')
   * delete('table1 AS alias1')
   * delete(array('table1' => 'alias1'))
   * delete(array('table1', 'table2'))
   *
   * @param mixed $tables
   *  string or array of the table names
   *
   * @return this
   */
  public function delete($tables)
  {
    $this->_sql->type = 'DELETE';

    if (!is_array($tables)) {
      $this->_sql->tables = "FROM $tables";
    } else {
      if (Utilities::is_assoc($tables)) {
        $tables = $this->_assoc_pairs($tables, 'AS');
      }
      $this->_sql->tables = 'FROM ' . implode(', ', $tables);
    }

    return $this;
  }

  /**
   * Create a 'from' text for the statement.
   *
   * from('t1')
   * from('t1 AS v1')
   * from(array('t1 AS v1', 't2 AS v2'))
   * from(array('t1' => 'v1', 't2' => 'v2'))
   *
   * @param mixed $tables
   *  string or array of the table names
   *
   * @return this
   */
  public function from($tables)
  {
    if (!is_array($tables)) {
      $this->_sql->tables = "FROM $tables";
    } else {
      if (Utilities::is_assoc($tables)) {
        $tables = $this->_assoc_pairs($tables, 'AS');
      }
      $this->_sql->tables = 'FROM ' . implode(', ', $tables);
    }

    return $this;
  }

  /**
   * Create a 'Where' text for the statement.
   *
   * where('c1 = v1')
   * where(array('c1', 'v2'))
   * where(array('c1', 'v2', '='))
   * where('AND', array('c1', 'v2', '='))
   *
   * @param mixed $where
   *  string or array of the table wheres
   *
   * @return this
   */
  public function where($where)
  {
    if (empty($this->_sql->where)) {
      $prefix = 'WHERE ';
    } else {
      $prefix = ' AND ';
    }
    if (!is_array($where)) {
      $sql = $where;
    } else if (sizeof($where) == 1) {
      $sql = getWhere($where[0]);
    } elseif (!is_array($where[1])) {
      $sql = $this->getWhere($where);
    } else {
      $prefix = $where[0];
      $sql = $this->getWhere($where[1]);
    }

    $this->_sql->where .= $prefix . $sql;

    return $this;
  }

  private function getWhere($where)
  {
    $str = '';
    if (!is_array($where)) {
      $str .= $where;
    } elseif (sizeof($where) > 1) {
      $str .= $where[0];
      $str .= isset($where[2]) ? $where[2] : '=';
      $str .= '"' . $where[1] . '"';
    }
    return $str;
  }

  /**
   * Create the order by part of the sql text.
   *
   * orderBy('col1')
   * orderBy('col1 DESC')
   * orderBy(array('col1', 'col2'))
   * orderBy(array(
   *    array('col1', 'ASC'),
   *    'col2',
   *    array('col1', 'DESC')
   * ))
   *
   * @param mixed $orderBy
   *  string or array of the order by's
   *
   * @return this
   */
  public function orderBy($orderBy)
  {
    if (!is_array($orderBy)) {
      $this->_sql->orderBy = "ORDER BY $orderBy";
    } else {
      $newOrderBy = array();
      foreach ($orderBy as $order) {
        if (!is_array($order)) {
          $newOrderBy[] = $order;
        } else {
          $ord = 'ASC';
          foreach ($order as $o) {
            if (in_array(strtoupper($o), array('ASC', 'DESC'))) {
              $ord = strtoupper($o);
            } else {
              $val = $o;
            }
          }
          $newOrderBy[] = "$val $ord";
        }
      }
      $this->_sql->orderBy = 'ORDER BY ' . implode(', ', $newOrderBy);
    }

    return $this;
  }

  /**
   * Create limit part of sql text.
   *
   * limit(10)
   * limit(array(10, 2))
   *
   * @param mixed $limit
   *  string or array of the limits
   * @return this
   */
  public function limit($limit)
  {
    if (!is_array($limit)) {
      $this->_sql->limit = "LIMIT $limit";
    } else {
      $this->_sql->limit = 'LIMIT ' . implode(', ', $limit);
    }

    return $this;
  }

  /**
   * Create the set part of an update sql text.
   *
   * set('col1 = "sdgdgr"')
   * set(array(
   *   'col1 = "sdgdgr"',
   *   array('col1', "sdgdgr")
   * ))
   *
   * @param mixed $set
   *  string or array of the sets
   *
   * @return this
   */
  public function set($set)
  {
    if (!is_array($set)) {
      $this->_sql->set = "SET $set";
    } else {
      $newSet = array();
      foreach ($set as $s) {
        if (is_array($s)) {
          $col = $s[0];
          $val = empty($s[1]) ? 'NULL' : '"' . $s[1] . '"';
          $newSet[] = "$col=$val";
        } else {
          $newSet[] = $s;
        }
      }
      $this->_sql->set = 'SET ' . implode(', ', $newSet);
    }

    return $this;
  }

  /**
   * Create the onDuplicate part of an insert sql text.
   *
   * onDuplicate('col1 = "sdgdgr"')
   * onDuplicate(array(
   *   'col1 = "sdgdgr"',
   *   array('col1', "sdgdgr")
   * ))
   *
   * @param mixed $onDup
   *  string or array of the onduplicate string
   *
   * @return this
   */
  public function onDuplicate($onDup)
  {
    if (!is_array($onDup)) {
      $this->_sql->onDuplicate = "ON DUPLICATE KEY UPDATE $onDup";
    } else {
      $newDup = array();
      foreach ($onDup as $od) {
        if (is_array($od)) {
          $col = $od[0];
          $val = empty($od[1]) ? 'NULL' : '"' . $od[1] . '"';
          $newDup[] = "$col=$val";
        } else {
          $newDup[] = $od;
        }
      }
      $this->_sql->onDuplicate = 'ON DUPLICATE KEY UPDATE ' . implode(', ', $newDup);
    }

    return $this;
  }

  /**
   * Utility function to reset the stored sub strings for the next query.
   *
   * @return void
   */
  private function _clear()
  {
    $this->_sql = new stdClass();

    $this->_sql->type = '';
    $this->_sql->cols = '';
    $this->_sql->tables = '';
    $this->_sql->joins = '';
    $this->_sql->where = '';
    $this->_sql->orderBy = '';
    $this->_sql->limit = '';
    $this->_sql->set = '';
    $this->_sql->onDuplicate = '';
  }

  /**
   * Convert an associative array into a string.
   *
   * Utility function to loop through an associative array and convert each
   * element into a string, using glue.
   *
   * @param array $aa
   *  associative array
   * @param string $g
   *  glue
   *
   * @return array $a
   */
  private function _assoc_pairs($aa, $g)
  {
    $a = array();
    foreach ($aa as $k => $v) {
      $a[] = "$k $g $v";
    }
    return $a;
  }

  /**
   * Execute sql query.
   *
   * Stores the query resource ID internally and returns true/false on success of query.
   *
   * @param string $sql
   *  sql db string
   *
   * @return mixed
   **/
  private function _exe($sql)
  {
    if ($this->debug > 1) {
      $result = $this->_db_time_query($sql);
    } else {
      $result = $this->_db_query($sql);
    }
    if ($result === FALSE) {
      Debug::variable($sql, "ERROR: query failed", 1, $this->debug);
    }

    $this->_clear();

    return $result;
  }

  /**
   * Internal function to execute sql query, display debug info.
   *
   * Stores the query resource ID internally.
   *
   * @param string $sql
   *  sql db string
   *
   * @return mixed
   **/
  private function _db_time_query($sql)
  {
    Debug::variable($sql, 'SQL', 1, $this->debug);
    $time_1 = Utilities::get_microtime();
    $ret_value = $this->_db_query($sql);
    $time_2 = Utilities::get_microtime();
    $time_total = $time_2 - $time_1;
    Debug::variable($time_total, "Timed query, time to process", 1, $this->debug);
    return $ret_value;
  }

  /**
   * Utility function to call.
   *
   * @param string $sql
   *  sql db string
   *
   * @return mixed
   **/
  private function _db_query($sql)
  {
    $this->_result = $this->db->query($sql);
    if ($this->transaction && !$this->_result) {
      $this->transactionOk = FALSE;
    }
    return $this->_result;
  }
}
